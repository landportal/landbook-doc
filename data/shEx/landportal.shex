prefix cex: 	      <http://purl.org/weso/computex/ontology#> 
prefix dcterms:       <http://purl.org/dc/terms/> 
prefix lb:            <http://purl.org/weso/landbook/ontology#> 
prefix qb: 	          <http://purl.org/linked-data/cube#> 
prefix rdf:           <http://www.w3.org/1999/02/22-rdf-syntax-ns#> 
prefix rdfs: 	      <http://www.w3.org/2000/01/rdf-schema#>
prefix sdmx-concept:  <http://purl.org/linked-data/sdmx/2009/concept#> 
prefix time:          <http://www.w3.org/2006/time#> 
prefix xsd:           <http://www.w3.org/2001/XMLSchema#>
prefix shex:          <http://www.w3.org/2013/ShEx/ns#>


# Schema for Observations 
<Observation> { 
  a                      ( qb:Observation )
, cex:ref-area           @<Area>            # Area affected by observation
, cex:ref-indicator      @<Indicator>       # Indicator
, cex:ref-time           @<Time>            # Time of observation
, cex:value              xsd:double         # Value of the observation
, cex:computation        @<Computation>     # Computation from which this observation has been obtained
, dcterms:issued         xsd:dateTime       # timestamp 
, qb:dataSet             @<DataSet>         # Dataset to which an observation belongs
, qb:slice               @<Slice>           # Slice to which this observation belongs
, rdfs:label             xsd:string         # Pattern "Value of {Region} in {Time} for indicator {Indicator}"@en
}

# Area should be an abstract type with Countries and Regions as subtypes
<Area> {
   a ( cex:Area )
 , rdfs:label xsd:string
}

<Country> {
   a ( lb:Country )
 , rdfs:label xsd:string  
 , lb:faoURI shex:IRI  
 , lb:iso2 xsd:string 
 , lb:iso3 xsd:string
}

<Indicator> {
  a   ( cex:Indicator )
, rdfs:label xsd:string
}

<Time> {
  a ( cex:Time )
, rdfs:label xsd:string
}

# <Year> {
#    & <Time> ,
#	time:year xsd:gYear 
#}

#<Interval> {
#    & <Time> ,
#	time:hasBeginning xsd:dateTime,
#	time:hasEnd       xsd:dateTime
#}

<Computation> {
 a ( cex:Computation )
}

#<Raw> {
# &<Computation> ,
# rdf:type             cex:Raw 
#}


<DataSet>{
 a ( qb:DataSet )
}

<Slice> {
 a ( qb:Slice)
}